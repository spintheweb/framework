#!/bin/bash
# Webspinner Server Release Script
# Creates a self-extracting installer with embedded runtime and configuration wizard
# Usage: ./deployment/build-server.sh

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "Webspinner Server Installer Release Generator"

# Check prerequisites
if ! command -v base64 &> /dev/null; then
  echo -e "${RED}Error: 'base64' command not found.${NC}"
  exit 1
fi

if ! command -v tar &> /dev/null; then
  echo -e "${RED}Error: 'tar' command not found.${NC}"
  exit 1
fi

if ! command -v gzip &> /dev/null; then
  echo -e "${RED}Error: 'gzip' command not found.${NC}"
  exit 1
fi

if ! command -v gh &> /dev/null; then
  echo -e "${YELLOW}Warning: 'gh' CLI not found. GitHub release creation will be skipped.${NC}"
  echo -e "${YELLOW}Install gh CLI: https://cli.github.com/${NC}"
  GH_AVAILABLE=false
else
  GH_AVAILABLE=true
fi

# Get current directory (should be repo root)
REPO_ROOT="$(cd "$(dirname "$0")/.." && pwd)"
cd "$REPO_ROOT"

# Determine default version from deno.json and allow override
ensure_v() {
  case "$1" in
    v*) echo "$1" ;;
    *) echo "v$1" ;;
  esac
}

DEFAULT_VERSION="v0.0.0"
if [ -f "$REPO_ROOT/deno.json" ]; then
  # Try to parse semver from deno.json without requiring jq
  BASE_VERSION=$(sed -n 's/.*"version"[[:space:]]*:[[:space:]]*"\([0-9][0-9.]*\)".*/\1/p' "$REPO_ROOT/deno.json" | head -n1)
  if [ -n "$BASE_VERSION" ]; then
    DEFAULT_VERSION=$(ensure_v "$BASE_VERSION")
  fi
fi

# Allow CLI override: --version vX.Y.Z, and non-interactive mode
CLI_VERSION=""
NON_INTERACTIVE=false
while [ $# -gt 0 ]; do
  case "$1" in
    --version)
      CLI_VERSION="$2"; shift ;;
    --non-interactive|--no-prompt|--yes|--ci)
      NON_INTERACTIVE=true ;;
    *) ;;
  esac
  shift || true
done

PROMPT_DEFAULT=${CLI_VERSION:-$DEFAULT_VERSION}
if [ "$NON_INTERACTIVE" = true ]; then
  VERSION="$PROMPT_DEFAULT"
else
  read -p "Release version [${PROMPT_DEFAULT}]: " VERSION
  VERSION=${VERSION:-$PROMPT_DEFAULT}
fi
VERSION=$(ensure_v "$VERSION")
echo -e "${GREEN}Creating server installer for version: $VERSION${NC}"
echo ""

# Create temporary directory for building
TEMP_DIR=$(mktemp -d)
PAYLOAD_DIR="$TEMP_DIR/webspinner-payload"
mkdir -p "$PAYLOAD_DIR"

echo -e "${BLUE}Step 1: Creating payload archive...${NC}"

# Copy runtime files to payload directory
cp -r stwComponents "$PAYLOAD_DIR/"
cp -r stwContents "$PAYLOAD_DIR/"
cp -r stwElements "$PAYLOAD_DIR/"
cp -r stwStyles "$PAYLOAD_DIR/"
cp -r webbaselets "$PAYLOAD_DIR/"
cp -r public "$PAYLOAD_DIR/"
# Include seed data for bare-metal installs
if [ -d ".data" ]; then
  cp -r .data "$PAYLOAD_DIR/"
fi
cp stwSpinner.ts "$PAYLOAD_DIR/"
cp deno.json "$PAYLOAD_DIR/"
cp deno.lock "$PAYLOAD_DIR/" 2>/dev/null || true
cp LICENSE "$PAYLOAD_DIR/"
cp README.md "$PAYLOAD_DIR/"

# Copy .env.example as .env (with safe defaults)
cp .env.example "$PAYLOAD_DIR/.env"

# Remove sensitive/unnecessary files from payload
find "$PAYLOAD_DIR" -type f \( -name "*.pem" -o -name "*.key" -o -name ".DS_Store" -o -name "Thumbs.db" \) -delete
# Preserve .data for fresh install. On upgrade, existing .data is left untouched by the installer.

echo -e "${GREEN}Payload directory prepared${NC}"

# Create payload tarball
PAYLOAD_TAR="$TEMP_DIR/payload.tar.gz"
tar -czf "$PAYLOAD_TAR" -C "$TEMP_DIR" webspinner-payload
echo -e "${GREEN}Payload archive created: $(du -h "$PAYLOAD_TAR" | cut -f1)${NC}"

# Create the installer script
OUTPUT_DIR="$REPO_ROOT/deployment/release"
mkdir -p "$OUTPUT_DIR"
INSTALLER_FILE="$OUTPUT_DIR/server.sh"

echo -e "${BLUE}Step 2: Generating self-extracting installer...${NC}"

# Write installer header
cat > "$INSTALLER_FILE" << 'INSTALLER_HEADER'
#!/bin/bash
# Webspinner Installer
# Self-extracting installer with configuration wizard
# Generated by build-server.sh

set -e

# Colors for output (only for errors)
RED='\033[0;31m'
NC='\033[0m'

# Must run as root
if [ "$EUID" -ne 0 ]; then
  echo -e "${RED}Error: This installer must be run as root.${NC}"
  echo "Please run: sudo $0"
  exit 1
fi

echo "Webspinner Server Installer"

INSTALL_DIR="/opt/webspinner"
SERVICE_INSTALL=true

# Optional upgrade behavior flags (default: preserve)
REPLACE_PUBLIC=false
REPLACE_DATA=false
for arg in "$@"; do
  case "$arg" in
    --replace-public)
      REPLACE_PUBLIC=true ;;
    --replace-data)
      REPLACE_DATA=true ;;
    --replace-all)
      REPLACE_PUBLIC=true; REPLACE_DATA=true ;;
    *) ;;
  esac
done

# Update package lists
echo "Updating package lists..."
if command -v apt-get &> /dev/null; then
  apt-get update -qq
elif command -v yum &> /dev/null; then
  yum check-update -q
elif command -v dnf &> /dev/null; then
  dnf check-update -q
elif command -v pacman &> /dev/null; then
  pacman -Sy --noconfirm
fi

# Check prerequisites

if ! command -v deno &> /dev/null; then
  echo "Installing Deno..."
    
  # Detect architecture
  ARCH=$(uname -m)
  case "$ARCH" in
    x86_64) DENO_ARCH="x86_64-unknown-linux-gnu" ;;
    aarch64|arm64) DENO_ARCH="aarch64-unknown-linux-gnu" ;;
    *) echo -e "${RED}Error: Unsupported architecture: $ARCH${NC}"; exit 1 ;;
  esac
    
  # Download latest Deno release directly to /usr/local/bin
  DENO_URL="https://github.com/denoland/deno/releases/latest/download/deno-${DENO_ARCH}.zip"
    
  if command -v curl &> /dev/null; then
    curl -fsSL "$DENO_URL" -o /tmp/deno.zip
  elif command -v wget &> /dev/null; then
    wget -qO /tmp/deno.zip "$DENO_URL"
  else
    echo -e "${RED}Error: Neither curl nor wget found. Cannot auto-install Deno.${NC}"
    exit 1
  fi
    
  # Extract to /usr/local/bin
  unzip -q -o /tmp/deno.zip -d /usr/local/bin
  chmod +x /usr/local/bin/deno
  rm /tmp/deno.zip
    
  # Verify installation
  if ! command -v deno &> /dev/null; then
    echo -e "${RED}Error: Deno installation failed.${NC}"
    exit 1
  fi
fi

# Auto-install nginx if missing
if ! command -v nginx &> /dev/null; then
  echo "Installing nginx..."
    
  # Detect package manager and install
  if command -v apt-get &> /dev/null; then
    apt-get install -y nginx >/dev/null 2>&1
  elif command -v yum &> /dev/null; then
    yum install -y nginx >/dev/null 2>&1
  elif command -v dnf &> /dev/null; then
    dnf install -y nginx >/dev/null 2>&1
  elif command -v pacman &> /dev/null; then
    pacman -S --noconfirm nginx >/dev/null 2>&1
  else
    echo -e "${RED}Error: Could not detect package manager.${NC}"
    exit 1
  fi
    
  # Enable and start nginx
  systemctl enable nginx >/dev/null 2>&1
  systemctl start nginx
fi

# Auto-install certbot if missing
if ! command -v certbot &> /dev/null; then
  echo "Installing certbot..."
    
  # Detect package manager and install
  if command -v apt-get &> /dev/null; then
    apt-get install -y certbot python3-certbot-nginx >/dev/null 2>&1
  elif command -v yum &> /dev/null; then
    yum install -y certbot python3-certbot-nginx >/dev/null 2>&1
  elif command -v dnf &> /dev/null; then
    dnf install -y certbot python3-certbot-nginx >/dev/null 2>&1
  elif command -v pacman &> /dev/null; then
    pacman -S --noconfirm certbot certbot-nginx >/dev/null 2>&1
  fi
fi

# Auto-install PostgreSQL if missing
if ! command -v psql &> /dev/null; then
  echo "Installing PostgreSQL..."
    
  # Detect package manager and install
  if command -v apt-get &> /dev/null; then
    apt-get install -y postgresql postgresql-contrib >/dev/null 2>&1
  elif command -v yum &> /dev/null; then
    yum install -y postgresql-server postgresql-contrib >/dev/null 2>&1
    postgresql-setup --initdb >/dev/null 2>&1
  elif command -v dnf &> /dev/null; then
    dnf install -y postgresql-server postgresql-contrib >/dev/null 2>&1
    postgresql-setup --initdb >/dev/null 2>&1
  elif command -v pacman &> /dev/null; then
    pacman -S --noconfirm postgresql >/dev/null 2>&1
    su - postgres -c "initdb -D /var/lib/postgres/data" >/dev/null 2>&1
  fi
    
  # Enable and start PostgreSQL
  systemctl enable postgresql >/dev/null 2>&1
  systemctl start postgresql
fi

# Ensure PostgreSQL cluster is initialized & running (covers edge cases where packaging didn't run initdb)
echo "Verifying PostgreSQL cluster..."
if ! su - postgres -c "psql -Atqc 'SELECT 1;'" >/dev/null 2>&1; then
  echo "PostgreSQL not responding to simple query; attempting cluster initialization..."
  # Common RedHat/Fedora path if install left empty data dir
  if [ -d /var/lib/pgsql ] && [ ! -d /var/lib/pgsql/data ]; then
    echo "Initializing cluster in /var/lib/pgsql/data ..."
    su - postgres -c "initdb -D /var/lib/pgsql/data" >/dev/null 2>&1 || true
  fi
  # Debian/Ubuntu normally auto-initialize; fallback if empty (rare minimal containers)
  if [ -d /var/lib/postgresql ] && [ -z "$(find /var/lib/postgresql -maxdepth 2 -type d -name main 2>/dev/null)" ]; then
    # Choose latest installed version directory if present
    PG_VER_DIR=$(find /usr/lib/postgresql -maxdepth 1 -mindepth 1 -type d 2>/dev/null | sort -V | tail -1)
    if [ -n "$PG_VER_DIR" ]; then
      PG_VERSION=${PG_VER_DIR##*/}
      TARGET_DIR="/var/lib/postgresql/$PG_VERSION/main"
      if [ ! -d "$TARGET_DIR" ]; then
        echo "Initializing Debian-style cluster at $TARGET_DIR ..."
        install -d -o postgres -g postgres "$TARGET_DIR"
        su - postgres -c "/usr/lib/postgresql/$PG_VERSION/bin/initdb -D '$TARGET_DIR'" >/dev/null 2>&1 || true
      fi
    fi
  fi
  # Generic helper if available
  if command -v postgresql-setup &>/dev/null; then
    echo "Running postgresql-setup --initdb (if not already initialized)..."
    postgresql-setup --initdb >/dev/null 2>&1 || true
  fi
  # Retry start
  systemctl start postgresql 2>/dev/null || systemctl restart postgresql 2>/dev/null || true
fi

# Final sanity check
if su - postgres -c "psql -Atqc 'SELECT 1;'" >/dev/null 2>&1; then
  echo "PostgreSQL cluster ready."
else
  echo "WARNING: PostgreSQL cluster initialization may have failed. Check service logs (journalctl -u postgresql)." >&2
fi

# Check if this is an upgrade
UPGRADE_MODE=false
if [ -d "$INSTALL_DIR" ] && [ -f "$INSTALL_DIR/stwSpinner.ts" ]; then
  UPGRADE_MODE=true
  echo ""
  echo "Existing installation detected at: $INSTALL_DIR"
  read -p "Continue with upgrade? (y/n) [y]: " CONTINUE_UPGRADE
  CONTINUE_UPGRADE=${CONTINUE_UPGRADE:-y}
  if [[ ! "$CONTINUE_UPGRADE" =~ ^[Yy]$ ]]; then
    echo "Upgrade cancelled."
    exit 0
  fi
    
  # Backup user data before upgrade
  BACKUP_DIR="$INSTALL_DIR/.backup-$(date +%Y%m%d-%H%M%S)"
  mkdir -p "$BACKUP_DIR"
    
  # Backup critical user data
  [ -f "$INSTALL_DIR/.env" ] && cp "$INSTALL_DIR/.env" "$BACKUP_DIR/"
  [ -d "$INSTALL_DIR/.data" ] && cp -r "$INSTALL_DIR/.data" "$BACKUP_DIR/"
  [ -d "$INSTALL_DIR/.cert" ] && cp -r "$INSTALL_DIR/.cert" "$BACKUP_DIR/"
    
  # Stop service if running
  if [ "$SERVICE_INSTALL" = true ] && systemctl is-active --quiet webspinner; then
    systemctl stop webspinner
    RESTART_SERVICE=true
  fi
fi

# Create installation directory
mkdir -p "$INSTALL_DIR"

# Extract payload
ARCHIVE_LINE=$(awk '/^__ARCHIVE_BELOW__/ {print NR + 1; exit 0;}' "$0")

# Extract to temporary location first
TEMP_EXTRACT=$(mktemp -d)
tail -n+$ARCHIVE_LINE "$0" | base64 -d | tar -xzf - -C "$TEMP_EXTRACT" --strip-components=1

# In upgrade mode, selectively copy files
if [ "$UPGRADE_MODE" = true ]; then
  # Update core Webspinner files only
  cp -r "$TEMP_EXTRACT/stwSpinner.ts" "$INSTALL_DIR/"
  cp -r "$TEMP_EXTRACT/stwComponents" "$INSTALL_DIR/"
  cp -r "$TEMP_EXTRACT/stwContents" "$INSTALL_DIR/"
  cp -r "$TEMP_EXTRACT/stwElements" "$INSTALL_DIR/"
  cp -r "$TEMP_EXTRACT/stwStyles" "$INSTALL_DIR/"
  cp -r "$TEMP_EXTRACT/deno.json" "$INSTALL_DIR/"
  cp -r "$TEMP_EXTRACT/deno.lock" "$INSTALL_DIR/" 2>/dev/null || true
  cp -r "$TEMP_EXTRACT/LICENSE" "$INSTALL_DIR/"
  cp -r "$TEMP_EXTRACT/README.md" "$INSTALL_DIR/"
    
  # Update system webbaselets (preserve custom)
  cp "$TEMP_EXTRACT/webbaselets/stw"*.wbdl "$INSTALL_DIR/webbaselets/" 2>/dev/null || true
    
  # Update public files; default preserves .data directory unless --replace-public
  if [ "$REPLACE_PUBLIC" = true ]; then
    echo "Replacing public directory contents (requested via --replace-public) ..."
    rsync -av --delete "$TEMP_EXTRACT/public/" "$INSTALL_DIR/public/" 2>/dev/null || {
      rm -rf "$INSTALL_DIR/public"/* 2>/dev/null || true
      cp -r "$TEMP_EXTRACT/public"/* "$INSTALL_DIR/public/" 2>/dev/null || true
    }
  else
    rsync -av --exclude='.data' "$TEMP_EXTRACT/public/" "$INSTALL_DIR/public/" 2>/dev/null || cp -r "$TEMP_EXTRACT/public"/* "$INSTALL_DIR/public/" 2>/dev/null || true
  fi

  # Optionally replace root .data directory if requested
  if [ "$REPLACE_DATA" = true ] && [ -d "$TEMP_EXTRACT/.data" ]; then
    echo "Replacing .data directory contents (requested via --replace-data) ..."
    rsync -av --delete "$TEMP_EXTRACT/.data/" "$INSTALL_DIR/.data/" 2>/dev/null || {
      mkdir -p "$INSTALL_DIR/.data"
      cp -r "$TEMP_EXTRACT/.data"/* "$INSTALL_DIR/.data/" 2>/dev/null || true
    }
  fi
else
  # Fresh install - copy everything
  cp -r "$TEMP_EXTRACT"/* "$INSTALL_DIR/"
fi

# Clean up temp directory
rm -rf "$TEMP_EXTRACT"

# Function to generate nginx configuration
generate_nginx_config() {
  local host=$1
  local port=$2
  local max_size=$3
  local output_file=$4
  local cert_dir="/etc/letsencrypt/live/$host"

  # If certs exist, emit dual HTTP->HTTPS + HTTPS server blocks; else emit HTTP only (certbot will amend later)
  if [ -f "$cert_dir/fullchain.pem" ] && [ -f "$cert_dir/privkey.pem" ]; then
    cat > "$output_file" << 'NGINXTLS'
server {
  listen 80;
  server_name $HOST;
  # Allow certbot challenges & redirect everything else to HTTPS
  location /.well-known/acme-challenge/ { root /var/www/html; }
  location / { return 301 https://$HOST$request_uri; }
  server_tokens off;
}

server {
  listen 443 ssl http2;
  server_name $HOST;
  ssl_certificate $CERTPATH/fullchain.pem;
  ssl_certificate_key $CERTPATH/privkey.pem;
  ssl_session_timeout 1d;
  ssl_session_cache shared:SSL:10m;
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_prefer_server_ciphers on;

  # Security headers (can be pared down if origin sets them all)
  add_header X-Content-Type-Options nosniff always;
  add_header X-Frame-Options SAMEORIGIN always;
  add_header X-XSS-Protection "1; mode=block" always;
  add_header Referrer-Policy no-referrer-when-downgrade always;

  location / {
    proxy_pass http://localhost:$WEBSPINNER_PORT;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_pass_header Server;
    proxy_pass_header X-Content-Type-Options;
    proxy_pass_header X-Frame-Options;
    proxy_pass_header X-XSS-Protection;
    proxy_pass_header Referrer-Policy;
    proxy_pass_header Content-Security-Policy;
    proxy_hide_header X-Powered-By;
    proxy_read_timeout 86400;
    proxy_connect_timeout 60;
    proxy_send_timeout 60;
  }
  client_max_body_size ${MAX_UPLOADSIZE}M;
  server_tokens off;
}
NGINXTLS
    sed -i "s/\$HOST/$host/g" "$output_file"
    sed -i "s/\$WEBSPINNER_PORT/$port/g" "$output_file"
    sed -i "s/\${MAX_UPLOADSIZE}/$max_size/g" "$output_file"
    sed -i "s#\$CERTPATH#$cert_dir#g" "$output_file"
  else
    cat > "$output_file" << 'NGINXHTTP'
server {
  listen 80;
  server_name $HOST;
  location / {
    proxy_pass http://localhost:$WEBSPINNER_PORT;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_pass_header Server;
    proxy_pass_header X-Content-Type-Options;
    proxy_pass_header X-Frame-Options;
    proxy_pass_header X-XSS-Protection;
    proxy_pass_header Referrer-Policy;
    proxy_pass_header Content-Security-Policy;
    proxy_hide_header X-Powered-By;
    proxy_read_timeout 86400;
    proxy_connect_timeout 60;
    proxy_send_timeout 60;
  }
  client_max_body_size ${MAX_UPLOADSIZE}M;
  server_tokens off;
}
NGINXHTTP
    sed -i "s/\$HOST/$host/g" "$output_file"
    sed -i "s/\$WEBSPINNER_PORT/$port/g" "$output_file"
    sed -i "s/\${MAX_UPLOADSIZE}/$max_size/g" "$output_file"
  fi
}

# Configuration wizard (skip if upgrade)
if [ "$UPGRADE_MODE" = false ]; then
echo ""

# Only prompt for domain/hostname
read -p "Domain/Hostname [labs.spintheweb.org]: " HOST
HOST=${HOST:-labs.spintheweb.org}

# Auto-configure everything else
USE_NGINX_PROXY=true
WEBSPINNER_PORT=8080
PORT=$WEBSPINNER_PORT
USE_TLS=y
CERTFILE=""
KEYFILE=""
SESSION_TIMEOUT=24
MAX_USERS=0
MAX_UPLOADSIZE=200
ALLOW_DEV="false"

# Create .env file
cat > "$INSTALL_DIR/.env" << EOF
# Webspinner Environment Configuration
# Generated during installation
HOST=$HOST
PORT=$PORT
CERTFILE=$CERTFILE
KEYFILE=$KEYFILE
SESSION_TIMEOUT=$SESSION_TIMEOUT
MAX_USERS=$MAX_USERS
SITE_ROOT="./public"
WEBBASE="./.data/webbase.wbdl"
COMMON_WEBBASE="./webbaselets/stwCommon.wbdl"
STUDIO_WEBBASE="./webbaselets/stwStudio.wbdl"
MAX_UPLOADSIZE=$MAX_UPLOADSIZE
DATASOURCES="./.data/datasources.json"
USERS="./.data/users.json"
ALLOW_DEV=$ALLOW_DEV
EOF

# Setup PostgreSQL database
echo "Setting up PostgreSQL database..."
DB_NAME="webspinner"
DB_USER="webspinner"
DB_PASS=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)

# Create database and user
su - postgres -c "psql -c \"CREATE DATABASE $DB_NAME;\"" 2>/dev/null || true
su - postgres -c "psql -c \"CREATE USER $DB_USER WITH PASSWORD '$DB_PASS';\"" 2>/dev/null || true
su - postgres -c "psql -c \"GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;\"" 2>/dev/null

# Update .env with database connection
cat >> "$INSTALL_DIR/.env" << EOF

# Database Configuration
DB_TYPE=postgresql
DB_HOST=localhost
DB_PORT=5432
DB_NAME=$DB_NAME
DB_USER=$DB_USER
DB_PASS=$DB_PASS
EOF

# Setup nginx reverse proxy
NGINX_CONF="/etc/nginx/sites-available/webspinner"
generate_nginx_config "$HOST" "$WEBSPINNER_PORT" "$MAX_UPLOADSIZE" "$NGINX_CONF"

# Enable site
ln -sf "$NGINX_CONF" /etc/nginx/sites-enabled/webspinner

# Test and reload nginx
if nginx -t 2>/dev/null; then
  systemctl reload nginx
    
  # Obtain Let's Encrypt certificate automatically
  echo "Obtaining SSL certificate..."
  if certbot --nginx -d "$HOST" --non-interactive --agree-tos --register-unsafely-without-email 2>/dev/null; then
    systemctl enable certbot.timer 2>/dev/null
  else
    echo "Note: SSL certificate setup failed. Run manually: sudo certbot --nginx -d $HOST"
  fi
else
  echo -e "${RED}Error: Nginx configuration test failed${NC}"
fi

# Close the upgrade mode conditional (configuration wizard was skipped if upgrade)
fi

# Update nginx configuration during upgrades (if nginx is configured)
if [ "$UPGRADE_MODE" = true ] && [ -f "/etc/nginx/sites-available/webspinner" ]; then
  echo "Updating nginx configuration with improved security headers..."
    
  # Read existing configuration to extract variables
  EXISTING_HOST=$(grep -oP 'server_name \K[^;]+' /etc/nginx/sites-available/webspinner | head -1 | tr -d ' ')
  EXISTING_PORT=$(grep -oP 'proxy_pass http://localhost:\K[0-9]+' /etc/nginx/sites-available/webspinner | head -1)
  EXISTING_MAX_SIZE=$(grep -oP 'client_max_body_size \K[0-9]+' /etc/nginx/sites-available/webspinner | head -1)
    
  # Backup existing config
  cp /etc/nginx/sites-available/webspinner /etc/nginx/sites-available/webspinner.bak.$(date +%Y%m%d-%H%M%S)
    
  # Generate updated nginx config with existing settings (preserve TLS if certs present)
  generate_nginx_config "$EXISTING_HOST" "$EXISTING_PORT" "$EXISTING_MAX_SIZE" "/etc/nginx/sites-available/webspinner"
    
  # Test and reload nginx
  if nginx -t 2>/dev/null; then
    systemctl reload nginx
    echo "Nginx configuration updated successfully"
  else
    echo -e "${RED}Error: Nginx configuration test failed, restoring backup${NC}"
    mv /etc/nginx/sites-available/webspinner.bak.* /etc/nginx/sites-available/webspinner
  fi
fi

# Create default data files if they don't exist
mkdir -p "$INSTALL_DIR/.data"

if [ ! -f "$INSTALL_DIR/.data/users.json" ]; then
  cat > "$INSTALL_DIR/.data/users.json" << 'EOF'
{
  "users": []
}
EOF
fi

if [ ! -f "$INSTALL_DIR/.data/datasources.json" ]; then
  cat > "$INSTALL_DIR/.data/datasources.json" << 'EOF'
{
  "datasources": []
}
EOF
fi

# Install systemd service automatically (if root)
if [ "$SERVICE_INSTALL" = true ]; then
  cat > /etc/systemd/system/webspinner.service << EOF
[Unit]
Description=Webspinner (WBDL interpreter)
After=network.target

[Service]
Type=simple
User=$SUDO_USER
WorkingDirectory=$INSTALL_DIR
ExecStart=/usr/local/bin/deno run --allow-net --allow-read --allow-write --allow-env --allow-run stwSpinner.ts
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable webspinner >/dev/null 2>&1
  systemctl start webspinner
fi

# Create start script for non-service installations
if [ "$SERVICE_INSTALL" = false ]; then
  cat > "$INSTALL_DIR/start.sh" << 'EOF'
#!/bin/bash
cd "$(dirname "$0")"
deno run --allow-net --allow-read --allow-write --allow-env --allow-run stwSpinner.ts
EOF
  chmod +x "$INSTALL_DIR/start.sh"
fi

# Final instructions
echo ""
if [ "$UPGRADE_MODE" = true ]; then
  echo "Upgrade complete!"
    
  # Restart service if it was running
  if [ -n "$RESTART_SERVICE" ] && [ "$RESTART_SERVICE" = true ]; then
    systemctl start webspinner
    sleep 1
    if ! systemctl is-active --quiet webspinner; then
      echo -e "${RED}Error: Service failed to restart. Check: journalctl -u webspinner${NC}"
    fi
  fi
else
  echo "Installation complete!"
  echo "Access your site at: https://$HOST"
fi

exit 0

__ARCHIVE_BELOW__
INSTALLER_HEADER

# Append base64-encoded payload
echo -e "${BLUE}Embedding payload...${NC}"
base64 "$PAYLOAD_TAR" >> "$INSTALLER_FILE"

# Make installer executable
chmod +x "$INSTALLER_FILE"

echo -e "${GREEN}✓ Installer created: $INSTALLER_FILE${NC}"

# Generate SHA256 checksum
echo ""
echo -e "${BLUE}Step 3: Generating checksum...${NC}"
CHECKSUM_FILE="$INSTALLER_FILE.sha256"
cd "$OUTPUT_DIR"
sha256sum "$(basename "$INSTALLER_FILE")" > "$(basename "$CHECKSUM_FILE")"
cd "$REPO_ROOT"
echo -e "${GREEN}✓ Checksum: $(cat "$CHECKSUM_FILE")${NC}"

# Get file size
INSTALLER_SIZE=$(du -h "$INSTALLER_FILE" | cut -f1)
echo -e "${BLUE}Installer size: $INSTALLER_SIZE${NC}"

# Clean up temporary directory
rm -rf "$TEMP_DIR"
echo -e "${GREEN}✓ Cleaned up temporary files${NC}"

# Git tag and GitHub release
echo ""
echo -e "${BLUE}Step 4: Creating Git tag and GitHub release...${NC}"

# Check if tag already exists
FORCE_TAG=n
if git rev-parse "$VERSION" >/dev/null 2>&1; then
  echo -e "${YELLOW}Warning: Tag $VERSION already exists${NC}"
  read -p "Force-update tag (will overwrite)? (y/n) [n]: " FORCE_TAG
  FORCE_TAG=${FORCE_TAG:-n}
    
  if [[ "$FORCE_TAG" =~ ^[Yy]$ ]]; then
    git tag -d "$VERSION" 2>/dev/null || true
    echo -e "${YELLOW}✓ Deleted old local tag${NC}"
    CREATE_TAG=y
  else
    echo "Skipping tag creation and release"
    CREATE_TAG=n
  fi
else
  CREATE_TAG=y
fi

# Single decision point
if [[ "$CREATE_TAG" =~ ^[Yy]$ ]]; then
  read -p "Create git tag and GitHub release for '$VERSION'? (y/n) [y]: " CREATE_TAG
  CREATE_TAG=${CREATE_TAG:-y}
    
  if [[ "$CREATE_TAG" =~ ^[Yy]$ ]]; then
    # Create and push tag
    git tag -a "$VERSION" -m "Release $VERSION (Server Installer) - $(date +'%Y-%m-%d %H:%M:%S')"
    echo -e "${GREEN}✓ Git tag created: $VERSION${NC}"
        
    if [[ "$FORCE_TAG" =~ ^[Yy]$ ]]; then
      git push origin "$VERSION" --force
      echo -e "${GREEN}✓ Tag force-pushed to remote${NC}"
    else
      git push origin "$VERSION"
      echo -e "${GREEN}✓ Tag pushed to remote${NC}"
    fi
        
    # Create GitHub release
    if [ "$GH_AVAILABLE" = true ]; then
      echo -e "${BLUE}Creating GitHub Release...${NC}"
            
      # Delete existing release if force-updating
      if [[ "$FORCE_TAG" =~ ^[Yy]$ ]]; then
        gh release delete "$VERSION" --yes 2>/dev/null || true
        echo -e "${YELLOW}✓ Deleted old GitHub release${NC}"
      fi
            
      RELEASE_NOTES="
### Overview

Production-ready self-extracting installer for Linux systems. Includes complete runtime, automated dependency installation, and production configuration.

### Components

- Spin the Web framework
- public directory
- Deno runtime
- nginx reverse proxy
- Let's Encrypt SSL/TLS
- PostgreSQL database
- systemd service

### Installation

\`\`\`bash
sudo ./server.sh
\`\`\`

### Upgrade

Run installer on existing installation to upgrade. Preserves configuration, user data, certificates, and custom webbaselets.

### Requirements

- Linux (Ubuntu, Debian, RHEL, CentOS, Fedora, Arch)
- Root privileges
- Ports 80/443 accessible
- DNS configured

### Verification

\`\`\`bash
sha256sum -c server.sh.sha256
\`\`\`

### Service Management

\`\`\`bash
systemctl status webspinner
systemctl restart webspinner
journalctl -u webspinner -f
\`\`\`

For documentation, see the [project wiki](https://github.com/spintheweb/webspinner/wiki)."

      gh release create "$VERSION" \
        --title "Release $VERSION (Server Installer)" \
        --notes "$RELEASE_NOTES" \
        "$INSTALLER_FILE" \
        "$CHECKSUM_FILE"
            
      echo -e "${GREEN}✓ GitHub release created${NC}"
      echo -e "${BLUE}View at: https://github.com/spintheweb/webspinner/releases/tag/$VERSION${NC}"
    else
      echo -e "${YELLOW}GitHub CLI not available${NC}"
      echo "To create release manually:"
      echo "  1. Go to: https://github.com/spintheweb/webspinner/releases/new"
      echo "  2. Choose tag: $VERSION"
      echo "  3. Upload: $INSTALLER_FILE"
      echo "  4. Upload: $CHECKSUM_FILE"
    fi
  else
    echo "Tag creation cancelled - skipping GitHub release"
  fi
fi

echo ""
echo -e "${GREEN}═══════════════════════════════════════════════${NC}"
echo -e "${GREEN}Server Release Complete!${NC}"
echo -e "${GREEN}═══════════════════════════════════════════════${NC}"
echo ""
echo -e "Installer: ${BLUE}$INSTALLER_FILE${NC}"
echo -e "Checksum:  ${BLUE}$CHECKSUM_FILE${NC}"
echo -e "Size:      ${BLUE}$INSTALLER_SIZE${NC}"
echo ""
